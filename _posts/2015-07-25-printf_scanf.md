---
id: 2329
title: 'Функции форматированного ввода/вывода: printf и scanf'
date: 2015-07-25T18:02:59+00:00
author: Catethysis
layout: post
guid: http://catethysis.ru/?p=2329
permalink: /printf_scanf/
wp_noextrenallinks_mask_links:
  - 0
ratings_users:
  - 1
ratings_score:
  - 5
ratings_average:
  - 5
dsq_thread_id:
  - 3969685766
categories:
  - Без рубрики
---
Очень многие не знают о существовании в языке C стандартных функций форматированного ввода, и особенно вывода данных. Простейший вывод числа в строчку порой превращается в по-настоящему адовые функции с кромсанием числа на разряды (обычно неэффективно реализованным), выделением памяти под строку и прочими ночными кошмарами.

Но всё это реализовано уже очень давно. Страшно сказать, но функция printf празднует в следующем году 50-летний юбилей! Да этих функций и не могло не быть &#8212; на заре развития компьютеров и компиляторов единственным средством общения программы с человеком был текстовый ввод-вывод.

Эти функции лежат в библиотеке stdio, подключим её:

<pre><code class="cpp">#include "stdio.h"</code></pre>

<!--more-->

Итак, функция которая понадобится вам чаще всего &#8212; sprintf. Она принимает:

  1. указатель на строку, в которую будет помещён результат (char *s)
  2. строку форматирования, например &#171;напряжение: %d, ток: %d&#187;
  3. перечень параметров, в этом примере &#8212; два целых числа. Здесь используются variable arguments.

sprintf работает как шаблонизатор: она читает строку форматирования, находит в ней идентификаторы, подставляет на их место значения переданных параметров и выводит результат в *s.

&nbsp;

В строке форматирования может быть несколько идентификаторов, тогда в качестве параметров должно быть передано такое же количество аргументов, и конечно они должны чётко соответствовать типу, указанному в идентификаторе.

## Самые частые случаи

Чаще всего вам понадобятся:

  * %d &#8212; вывод целого числа: _sprintf(s, &#171;масса: %d грамм&#187;, 2358)_ => &#171;масса: 2358 грамм&#187;
  * %f &#8212; вывод дробного числа: _sprintf(s, &#171;пинг: %f секунды&#187;, 1.432)_ => &#171;пинг: 1.432 секунды&#187;
  * %s &#8212; вывод строки: _sprintf(s, &#171;json: {\&#187;name\&#187;: \&#187;%s\&#187;}&#187;, &#171;joe&#187;)_ => &#171;json: {&#171;name&#187;: &#171;joe&#187;}&#187;
  * %02X &#8212; вывод байта в виде hex: _sprintf(s, &#171;CRC: %02X %02X&#187;, 0x43, 0xfe)_ => &#171;CRC: 43 FE&#187;

Некоторые символы, такие как &#171;, нужно экранировать слешом: \&#187;

Можно добавлять управляющие последовательности, например \n &#8212; перевод строки.

## Описание

Теперь подробнее.

Каждый идентификатор начинается с символа &#171;%&#187;, и сообщает всё о переменной, значение которой нужно подставить: её тип и модификаторы (ширина, точность, размер). Формат идентификатора:

<pre>%[флаги][ширина][.точность][размер]тип</pre>

Ни один из элементов не является обязательным, кроме типа. Часть элементов относятся только к некоторым типам, например ширина, точность и размер &#8212; только к числовым типам.
  
Между элементами могут стоять пробелы, но делать так нельзя &#8212; резко увеличивается вероятность ошибки.

## Числовые целые типы

%d/%i, %u, %o, %x/%X &#8212; всё это типы целых чисел int (т.е. оно имеет длину равную разрядности платформы).

%d и %i &#8212; десятичное целое знаковое число, минус ставится только у отрицательных чисел.
  
%u &#8212; десятичное целое беззнаковое число.
  
%o &#8212; восьмеричное представление int.
  
%x &#8212; шестнадцатиричное представление int в строчном формате: 0..9, a..f.
  
%X &#8212; шестнадцатиричное представление int в прописном формате: 0..9, A..F.

К ним можно применить **модификаторы размера**:
  
%l &#8212; число интерпретируется как long int = int16_t
  
%ll &#8212; long long int = int32_t
  
%h &#8212; short int
  
%hh &#8212; char

**Флаги**:
  
%0d &#8212; вывод ведущих нулей, дополняя число до длины, указанной в поле &#171;ширина&#187;
  
%-d &#8212; выравнивание числа по левому краю

И **размерность**:
  
%2d &#8212; длина числа минимум 2 символа. Если меньше &#8212; оно будет дополнено слева пробелами (либо нулями, если есть флаг 0)

Я очень часто использую идентификатор %02X для вывода шестнадцатиричных чисел в пакетах данных, например:
  
_sprintf(s, &#171;%02X %02X %02X&#187;, 0xb3, 0x54, 0xaf)_ => &#171;B3 54 AF&#187;

## Типы с плавающей точкой

%f, %e

%f &#8212; float
  
%e &#8212; экспоненциальная запись

**Модификатор размера** только один:
  
%lf &#8212; double

К ним можно применить те же самые **флаги** 0 и -, а также можно указать **ширину и точность**:
  
%.2f &#8212; выведет float с двумя знаками после запятой. Если они равны 0 &#8212; они всё равно будут выведены, поэтому так можно делать красиво выровненные таблички.
  
%10.2f &#8212; как и в прошлой главе, дополнит число нулями или пробелами до длины 10 символов.

## Символы

%c выводит символ с кодом, переданным в качестве параметра.

## Строки

%s выводит переданную строку, вплоть до её терминирующего нуля.

## Особые типы

%n записывает в переданную переменную счётчик символов &#8212; количество символов, которое было выведено на момент появления этого идентификатора.

%p выводит адрес указателя.

%% выводит символ &#171;%&#187;

## Варианты функций printf

Мы уже рассмотрели функцию sprintf, как наиболее полезную при программировании под МК &#8212; она выводит текст в переданный указатель на строку. Но это не единственная функция из семейства:

  * printf(char *format, &#8230;) &#8212; выводит текст в стандартный вывод (STDIO). Больше применима при программировании для компьютера, но в принципе вы можете переопределить встроенную функцию putc, чтобы она выводила символ как-то по-другому &#8212; и сможете, например, выводить через printf напрямую на ЖК-экран.
  * snprintf(char \*s, int n, char \*format, &#8230;) &#8212; ограничивает количество выведенных символов параметром n, непоместившиеся символы будут потеряны. Очень полезно, если у вас есть какой-то накопительный буфер, который нельзя переполнять.
  * fprintf(FILE \*f, char \*format, &#8230;) &#8212; выводит текст в файл. Опять же, в основном используется на ПК, но опять же вы можете переопределить её и, например, выводить данные в SD-карту.
  * vprintf(char *format, va_list va) &#8212; использует перечень аргументов variable arguments. Это просто незаменимая фича при написании своей обёртки вокруг printf.

Все функции вида printf возвращают количество записанных символов.

## scanf

Функция, обратная sprintf &#8212; это sscanf. Она принимает строку с данными и текстом, пытается её разобрать в соответствии со строкой форматирования, и записывает найденные данные по переданным адресам. Простейший пример:

<pre>float lat, lon;
sscanf("GPS lat: 63.321, lon: 37.867", "GPS lat: %f, lon: %f", &lat, &lon);</pre>

Здесь действуют все те же самые правила составления идентификаторов, что и в printf, и есть все те же самые функции вроде scanf, fscanf, sscanf.