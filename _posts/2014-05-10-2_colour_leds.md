---
id: 1381
title: Двухцветные светодиоды
date: 2014-05-10T21:22:22+00:00
author: catethysis
layout: post
guid: http://catethysis.ru/?p=1381
permalink: /2_colour_leds/
ratings_users:
  - 2
  - 2
  - 2
ratings_score:
  - 10
  - 10
  - 10
ratings_average:
  - 5
  - 5
  - 5
wp_noextrenallinks_mask_links:
  - 0
  - 0
  - 0
dsq_thread_id:
  - 2729687793
categories:
  - Электроника
tags:
  - STM32
  - электроника
---
На рынке существуют двухцветные светодиоды. Устроены они так: внутри корпуса установлены два светодиода разного цвета, соединённых параллельно но в разной полярности. Таким образом, если приложить напряжение одной полярности &#8212; светится один кристалл и светодиод излучает, к примеру, красный свет. Если изменить полярность &#8212; загорится другой кристалл, и станет гореть зелёный цвет. Понятно, что противоположный светодиод не пропускает ток не своей полярности, и не горит.

Это позволяет одним светодиодом отображать, например, два состояния какой-то системы: зелёный для нормальной работы и красный для индикации ошибки. Довольно часто такие светодиоды ставятся внутрь кнопки, и нажатие кнопки дублируется перемигиванием светодиода, или переключением его в другой цвет (конечно, это делается внешним МК).

Но не все знают, что таким светодиодом можно показывать ещё и третий цвет! Никакой rocket science, нужно просто быстро переключать светодиод из одного цвета в другой. Я покажу, как это сделать на STM32 &#8212; сначала неправильно, а потом правильно.

<!--more-->

Нам ведь важна только разность потенциалов на выводах светодиода? Поэтому удобнее всего поступить так: подключим светодиод к двум ногам ввода-вывода, для включения одного цвета подадим &#171;1&#187; на первую ногу и &#171;0&#187; на вторую. На светодиоде, таким образом, будет напряжение +3,3В, и светится зелёный цвет. Если же поменять полярность, подать &#171;0&#187; на первую ногу и &#171;1&#187; на вторую &#8212; на светодиоде получится напряжение -3,3В, и загорится красный цвет. Конечно, нельзя забывать о токоограничительном резисторе, который не даст току подняться выше 10-20мА.

## Неправильный, но простой метод

Всё очень просто: подключаем светодиод через 330Ом резистор к каким-нибудь ножкам ввода-вывода, и в цикле их включаем и выключаем. Я использую PB0 и PB2 на плате STM32VLDiscovery.

Код будет очень простым:

<pre>#include "stm32f10x_conf.h"

void main()
{
 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 
 GPIO_InitTypeDef GPIO_InitStructure;
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_2;
 GPIO_Init(GPIOB, &GPIO_InitStructure);
 
 GPIOB-&gt;ODR=0;
#define del1 3000
#define del2 10000
 int i;
 while(1)
 {
 GPIOB-&gt;ODR=GPIO_Pin_0;
 for(i=0; i&lt;del1; i++);
 
 GPIOB-&gt;ODR=GPIO_Pin_2;
 for(i=0; i&lt;del2; i++);
 }
}</pre>

<a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/http://static.catethysis.ru/files/2-colour%20LED - DELAY.rar" >Скачать проект</a>

Почему это неправильный метод &#8212; я объяснял в более ранних статьях. Дело в том, что в большой программе мигание светодиодом вряд ли является основной задачей, и блокировать работу процессора такими вот пустыми циклами &#8212; крайне расточительно, и у нас уходит ценное время для выполнения более важных задач.

## Более сложный, но правильный метод

Воспользуемся таймерами в кристалле STM32! Они могут взять на себя реализацию всех этих задержек и циклов, разгрузив от них ядро. Достаточно всего один раз настроить таймер, включить его &#8212; и можно заниматься своими делами, изредка отвлекаясь на прерывания.

<pre>#include "stm32f10x_conf.h"

int a=0;

void TIM6_DAC_IRQHandler(void)
{
 if (TIM6-&gt;SR & TIM_SR_UIF) {
 // Сбрасываем флаг прерывания
 TIM6-&gt;SR &= ~TIM_SR_UIF;
 
 if(a) GPIOB-&gt;ODR=GPIO_Pin_0;
 else GPIOB-&gt;ODR=GPIO_Pin_2;
 a=!a;
 }
}

void main()
{
 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 
 GPIO_InitTypeDef GPIO_InitStructure;
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_2;
 GPIO_Init(GPIOB, &GPIO_InitStructure);
 
 GPIOB-&gt;ODR=0;
 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE); 

 // Настраиваем прескалер. При тактовой частоте 24МГц частота
 // таймера будет равна 24МГц/240 = 100кГц
 TIM6-&gt;PSC = 240;

 // Настраиваем период таймера = 1000 циклов - полный цикл таймера
 // будет равен 1/100кГц*1000 = 10 миллисекунд.
 TIM6-&gt;ARR = 1000;
 TIM6-&gt;DIER |= TIM_DIER_UIE;
 NVIC_EnableIRQ(TIM6_DAC_IRQn);
 TIM6-&gt;CR1 |= TIM_CR1_CEN;
 
 while(1);
}</pre>

<a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/http://static.catethysis.ru/files/2-colour%20LED - TIM.rar" >Скачать проект</a>

## Регулировка яркости двухцветного светодиода

С двухцветными светодиодами всегда возникает проблема &#8212; яркость кристаллов разная, и если включать их с одинаковой скважностью (к примеру, 50% времени красный, 50% времени зелёный) &#8212; цвета смешиваются неточно, и получается не то что мы хотели. Красные светодиоды всегда выглядят ярче, чем зелёные &#8212; и получается не жёлтый и даже не оранжевый цвет, а практически полностью красный.

Очевидный программный способ регулировки яркости &#8212; поставить разные длительности задержек: в первом примере для этого достаточно изменить дефайны del1 и del2, во втором примере потребуется загружать в регистр ARR разные значения на разных шагах. Но это всё понятно и вопросов не возникает.

Аппаратный способ регулировки для кого-то может быть не столь очевидным. Понятно что можно изменить сопротивление токоограничительного резистора, но так изменится яркость обоих кристаллов. Поэтому сделаем немного хитрее &#8212; пустим ток в одном направлении по одному резистору, а в другом направлении &#8212; по другому. Это, конечно, очень легко сделать двумя диодами.

<img class="alignnone" src="http://static.catethysis.ru/files/2-colour-LED-resistors.png" alt="" width="474" height="664" />