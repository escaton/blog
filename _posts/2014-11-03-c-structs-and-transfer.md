---
id: 2078
title: Структуры в Си и их передача
date: 2014-11-03T19:06:18+00:00
author: Catethysis
layout: post
guid: http://catethysis.ru/?p=2078
permalink: /c-structs-and-transfer/
wp_noextrenallinks_mask_links:
  - 0
ratings_users:
  - 5
ratings_score:
  - 25
ratings_average:
  - 5
dsq_thread_id:
  - 3180077179
categories:
  - Справочник
tags:
  - c
---
Структура — это удобное хранилище для разнородных данных, которые хочется объединить. К примеру, вы можете создать структуру, описывающую параметры вашего устройства — сетевые настройки, таймаут спящего режима, его идентификатор и прочее подобное, типа какой-нибудь строки приветствия и состояния светодиода. Раз все параметры будут храниться в одном месте — они всегда будут на виду, да и нормальные IDE будут вам подсказывать поля структуры при обращении к ним. Ещё мы рассмотрим хранение и восстановление структур из архива, а также их передачу по сети.
  
Объявление такой структуры:

<pre><code class="cs">struct {
	uint32_t ID;
	char IP[4];
	uint16_t timeout;
	bool led;
	char text[12];
} params;</code></pre>

Как это работает?

<!--more-->


  
В си довольно удобный синтаксис, в том плане что многие вещи записываются как &#171;тип_данных переменная&#187;, начиная с &#171;int i&#187; заканчивая &#171;void main() {}&#187;. Так и здесь, кодовое слово struct начинает объявление структуры, и весь кусок кода &#171;struct { &#8230; }&#187; просто задаёт новый тип. Соответственно, params — это уже готовая переменная (экземпляр типа), которую можно использовать. Внутри фигурных скобок перечислены все поля структуры, которые потом будут доступны так: params.ID или params.IP[2]. Длина полей должна быть фиксированной, поэтому нельзя использовать строки вида *text, только массивы вида text[12].
  
Можно было сделать немного иначе: объявить только тип, а переменную завести позже. Для этого мы использовали бы ключевое слово typedef и написали так:

<pre><code class="cs">typedef struct {
	uint32_t ID;
	char IP[4];
	uint16_t timeout;
	bool led;
	char text[12];
} params_struct;
params_struct params;</code></pre>

Так появляется возможность оставить все объявления структурных типов в отдельном файле (header), а в главном файле просто использовать уже готовые структурные типы для объявления структур прямо по месту.
  
Конечно, в обоих вариантах вы можете объявить сколько угодно экземпляров структур, или создать массив из них:

<pre><code class="cs">struct {
	uint32_t ID;
	char IP[4];
	uint16_t timeout;
	bool led;
	char text[12];
} params1, params2, params[10];</code></pre>

Вариант с массивом особенно удобен для сервера в клиент-серверной топологии сети — на каждом клиенте хранятся в структуре его собственные параметры, а на мастер-устройстве располагается таблица параметров всех клиентов в виде массива структур.
  
В принципе, ничего сложного в структурах нет, а с темой серверов и клиентов мы плавно подошли к более интересной теме:

## Хранение, передача и синхронизация структур

Для многих будет удивлением то, что данные структуры хранятся в памяти в виде плоского списка, все поля структуры просто идут в памяти друг за другом. Поэтому становится возможным обращаться с этой структурой как с простым массивом байт! Проверим, создадим массив &#171;поверх&#187; этой структуры.
  
Начальное смещение получим так:

<pre><code class="cs">char *Bytes = &params;</code></pre>

мы объявили указатель char и поместили в него адрес params. Теперь Bytes указывает на первый байт структуры, и при последовательном чтении мы побайтно прочитаем всю структуру. Но сколько байт нужно прочитать? Для этого рассмотрим две интересных функции.

### sizeof и offsetof

Это даже не функции, а встроенные макросы языка Си. Начнём с более простой, **sizeof**.
  
Компилятор заменяет все записи вида sizeof X на значение длины Х. В качестве X может выступать как тип, так и экзмепляр типа, т.е. в нашем случае можно подставить в sizeof и тип структуры (если мы его заводили с помощью typedef), и саму переменную структуры так: sizeof params_struct или sizeof params. Она пройдёт по всем полям структуры, сложит их длины и отдаст сумму, которая и будет длиной структуры.

**offsetof** — настоящий макрос, который принимает два параметра (структуру \_s\_ и поле \_m\_ в ней) и отдаёт положение этого поля в структуре, его смещение относительно начала структуры. Выглядит этот макрос очень просто:

<pre><code class="cs">offsetof(s, m) (size_t)&(((s *)0)-›m).</code></pre>

Как он работает?

  1. Берём число 0
  2. Преобразуем его к типу &#171;указатель на структуру s&#187;: (s*)0
  3. Обращаемся к полю m из этой структуры: ((s*)0)->m
  4. Вычисляем его адрес: &(((s*)0)->m)
  5. Преобразуем адрес к целому числу: (size_t)&(((s*)0)->m)

Магия именно в первом шаге, в котором мы берём 0. Благодаря этому на четвёртом шаге абсолютный адрес поля, вычисленный компилятором, оказывается отсчитан относительно начала структуры — структуру-то мы положили в адрес 0. Таким образом, после выполнения этого макроса мы реально имеем смещение поля относительно начала структуры. Понятно, что этот макрос правильно определит смещения даже в сложных и вложенных структурах.

Здесь нужно сделать небольшое отступление. Дело в том, что я рассматривал самый простой случай, когда поля упакованы точно вслед друг за другом. Есть и другие методы упаковки, которые называются &#171;выравнивание&#187;. К примеру, можно выдавать каждому полю &#171;слот&#187;, кратный 4 байтам, или 8 байтам. Тогда даже char будет занимать 8 байт, и общий размер структуры вырастет, а все смещения сдвинутся и станут кратны выравниванию. Эта штука полезна при программировании для компьютера, поскольку из-за грануляции ОЗУ процессор гораздо быстрее умеет извлекать из памяти выровненные данные, ему требуется на это меньше операций.

## Работа с массивом из структуры

Окей, теперь мы умеем представлять любую структуру в виде массива байт, и обратно. Вы поняли фишку? У нас теперь одна и та же область памяти имеет роли &#171;структура&#187; и &#171;массив&#187;. Изменяем что-то в структуре — меняется массив, меняем массив — меняется структура.
  
В этом — суть процесса! У нас нет отдельного массива, потому что сама структура — это уже массив, и мы просто обращаемся к памяти разными методами. И у нас нет никаких копирующих циклов по полям или по байтам, этот цикл будет уже сразу в функции передачи.

Теперь осталось лишь научиться удобно с этим всем работать.

### Хранение и передача структуры

Чтобы создать архивную копию структуры, для передачи по сети или для складывания её в надёжное место — отдайте в вашу функцию передачи данных адрес этого массива. К примеру, моя функция записи массива данных в EEPROM выглядит так: I2C\_burst\_write (I2Cx, HW\_address, addr, n\_data, \*data). Вам просто нужно вместо n_data передать sizeof params, а вместо \*data — &params:

<pre><code class="cs">I2C_burst_write (I2Cx, HW_address, addr, sizeof params, &params)</code></pre>

Функции передачи данных по сети обычно выглядят примерно так же. В качестве данных передавайте &params, а в качестве длины данных — sizeof params.

### Приём и восстановление структуры

Всё точно так же. Моя функция чтения массива из EEPROM: I2C\_burst\_read (I2Cx, HW\_address, addr, n\_data, \*data). n_data = sizeof params, \*data = &params:

<pre><code class="cs">I2C_burst_read (I2Cx, HW_address, addr, sizeof params, &params)</code></pre>

Не забывайте, что вы сразу пишете принятые байты непосредственно в структуру. При медленной или ненадёжной передаче имеет смысл записать данные во временный буфер, и после их проверки передать их в структуру через

<pre><code class="cs">memcpy(&params, &temp_buffer, sizeof params).</code></pre>

Реализовав эти методы, мы воплотим удобную синхронизацию двух структур, находящихся на разных компьютерах: клиент-микроконтроллер может быть хоть на другой стороне земного шара от сервера, но передать структуры будет всё так же просто.

### Хранение/восстановление отдельных полей

И зачем же мы так долго рассматривали макрос offsetof? Его очень удобно использовать для чтения и записи отдельных полей структуры, например так:

<pre><code class="cs">I2C_burst_write (I2Cx, HW_address, addr + offsetof(params, IP), sizeof params.IP, &params.IP)</code>
I2C_burst_read  (I2Cx, HW_address, addr + offsetof(params, IP), sizeof params.IP, &params.IP)</pre>

Ну и вообще, было бы неплохо сделать удобные макросы-обёртки для этой цели.

<pre>#define store(structure, field) I2C_burst_write (I2Cx, HW_address, addr + offsetof(structure, field), sizeof(structure.field), &(structure.field))
#define load(structure, field)  I2C_burst_read  (I2Cx, HW_address, addr + offsetof(structure, field), sizeof(structure.field), &(structure.field))</pre>