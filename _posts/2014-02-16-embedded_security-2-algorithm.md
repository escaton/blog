---
id: 957
title: Безопасность во встраиваемых системах / алгоритм
date: 2014-02-16T19:04:45+00:00
author: catethysis
layout: post
guid: http://catethysis.ru/?p=957
permalink: /embedded_security-2-algorithm/
notely:
  - 
  - 
  - 
wp_noextrenallinks_mask_links:
  - 0
  - 0
  - 0
ratings_users:
  - 1
  - 1
  - 1
ratings_score:
  - 5
  - 5
  - 5
ratings_average:
  - 5
  - 5
  - 5
dsq_thread_id:
  - 2732591910
categories:
  - Электроника
tags:
  - безопасность
  - электроника
---
В современном эмбеде от программы зависит даже больше, чем от железа. Хорошо написанная программа может вообще не зависать и ни разу не вызвать срабатывание вотчдога (но это совсем не повод его не использовать!).

Хорошее подспорье при написании правильных программ &#8212; стандарт **MISRA C**. Однако нужно понимать, что он &#8212; всего лишь свод правил непосредственно кодинга. Он не подскажет вам, какой алгоритм лучше использовать и как его реализовать.

Я же хочу привести список неких good practice для эмбед-программиста, следование которым лишит вас некоторой головной боли при разработке алгоритмов.

<!--more-->

## Контрольные суммы

Все критически важные куски данных должны сопровождаться контрольной суммой. Причём желательно использовать такие суммы, которые:

  1. не обращаются в ноль на входном потоке с нулевыми байтами, т.е. 0 не является особым значением и не вырождает эту сумму в 0.
  2. не дают одинаковых значений для &#171;данные&#187; и &#171;данные + 0x00&#8243;, т.е. чувствительны к длине данных.
  3. не дают одинаковых значений для &#171;0x01 0x00&#8243; и &#171;0x00 0x01&#8243;, т.е. чувствительны к перестановке байт.

Обычные &#171;суммы&#187; &#8212; такие как простая сумма, или последовательный xor всех байт, к сожалению, **не обладают** ни одним из этих свойств. Поэтому применять их нельзя, несмотря на всю простоту их вычисления. Собственно, потому и нельзя, потому что они слишком просты <img src="http://catethysis.ru/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" />

Однако, давно существуют алгоритмы, удовлетворяющие всем этим требованиям &#8212; например, семейство **CRC**-функций. Математические институты нашли среди них очень хорошие функции, но в принципе использовать можно любую. Единственная их проблема (вырождение в ноль) решается ненулевым начальным значением (например, 0xFFFF&#8230;).

К тому же, есть хороший способ здорово **усложнить жизнь злоумышленнику**, решившему вскрыть вашу CRC &#8212; какое-то особое нетривиальное начальное значение, не 0 и не 0xFFFF &#8212; а ваше собственное.

Дополнительное пожелание &#8212; как можно больший диапазон возможных значений суммы. Если сумма имеет длину 1 байт, это значит что есть всего 256 различных значений суммы, и вероятность совпадения сумм у разных кусков данных равна 0,4%. Это  довольно много, поэтому лучше увеличить количество различных сумм, увеличив её длину например до 2 байт. Это &#8212; **CRC-16**, и вероятность снижается до 0,002% &#8212; уже вполне приемлемо. Есть ещё и CRC-32, но думаю что можно ограничиться и 2 байтами.

Конечно, избыточное кодирование и коды с коррекцией ошибок &#8212; ещё более классная штука, но это уже следующий шаг развития.

## Конечные автоматы

Порой реализация сложного алгоритма становится настоящей мукой. Да даже какие-нибудь простые алгоритмы вроде описания работы лифта, по мере обрастания дополнительными датчиками и проверками превращаются в кашу, которую тяжело распутать и легко сломать. Более того, вы вполне можете оставить там ошибку, которая всплывёт только в продакшене.

Применим научный подход. Хороший способ анализа таких заданий &#8212; разложение всей совокупности на отдельные &#171;атомарные&#187; состояния. К примеру, &#171;нажали кнопку&#187;, &#171;едем вниз&#187;, &#171;сработал датчик этажа&#187; и так далее. Также нужно найти все связи между этими состояниями.

Теперь переходим к синтезу алгоритма. Самый хороший способ &#8212; применение **конечных автоматов**. Они дадут вам возможность буквально напрямую перенести список состояний и связей в программу. Получится что-то похожее на блок-схему.

Кстати, стек TCP/IP в большинстве случаев реализуется на конечных автоматах.

## Время ожидания

Не полагайтесь всецело на то, что вам ответят на запрос. Если внешняя система занята, не отвечает или вообще отвалилась &#8212; это не должно приводить к зависанию вашей программы. Любые запросы с ожиданием ответа делайте либо совсем неблокирующими, либо ставьте на них таймаут с помощью таймера. Под блокированием я имею в виду не настоящее блокирование процессора пустым циклом (понятно, что так делать нельзя ни при каких обстоятельствах), а &#171;зависание&#187; вашего конечного автомата или другого алгоритма в определенном состоянии, из которого уже нельзя вылезти.

Пример из моего недавнего опыта: периодически по таймеру отправляю запрос, и останавливаю таймер на время ожидания ответа. Адресат любит подумать, и может не сразу ответить &#8212; поэтому я не хотел зафлудить размышляющего адресата запросами (а то потом мне же разбираться с пришедшей ахинеей). После получения ответа снова запускаю таймер.
  
Если же адресат случайно не ответит на один из запросов (даже не из-за зависания, а из-за какого-то случайного сбоя связи) &#8212; таймер **никогда не запустится снова**. Исправил программу так: не останавливаю таймер, а настраиваю его на некое время ожидания ответа. Если ответа за это время нет &#8212; возвращаюсь в состояние IDLE.

## Event-driven

Хороший стиль заключается в том, чтобы следовать методологии event-driven, то есть выполнять какие-то действия как **реакцию на события**. Это даст возможность не проверять постоянно одно и тоже или регулярно запрашивать неизменные значения &#8212; а высвободить время на действительно полезные дела. Или на сон, что тоже неплохо. Значительно помогут вам в этом прерывания, в том числе от таймеров.

## Не принимать мусор

Интересная идея кроется в общении &#171;запрос&#187;-&#171;ответ&#187;. Если адресат не может сам инициировать общение &#8212; зачем нам вообще слушать канал связи в промежутках между сеансами? Захотел чего-то спросить &#8212; включил связь, спросил, получил ответ, выключил связь. Включение UART-контролера &#8212; дело 1 миллисекунды, а возможность не получать всякий незапрошенный мусор и не думать, что с ним сделать &#8212; бесценна <img src="http://catethysis.ru/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" />

## Используйте RTOS

Очень полезным подспорьем становится использование разнообразных RTOS. Благодаря им вы не думаете о синхронизации асинхронных процессов, а просто пишете код. Я написал [гайд по установке FreeRTOS на STM32F100](http://catethysis.ru/index.php/freertos_stm32f100_iar/ "Установка FreeRTOS на STM32F100 / VLDiscovery в IAR") &#8212; использование FreeRTOS здорово помогло мне в том числе при разработке [проекта с Ethernet](http://catethysis.ru/index.php/stm32-lan8720-freertos-iar/ "STM32 + LAN8720 + FreeRTOS + IAR").

&nbsp;

Ну и чтобы закончить на весёлой ноте: помните, что одно из свойств машины Тьюринга &#8212; её потенциальная способность к зависанию <img src="http://catethysis.ru/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" />