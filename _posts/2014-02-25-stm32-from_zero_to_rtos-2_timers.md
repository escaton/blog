---
id: 1023
title: 'STM32 — с нуля до RTOS. 2: Таймер и прерывания'
date: 2014-02-25T15:34:32+00:00
author: catethysis
layout: post
guid: http://catethysis.ru/?p=1023
permalink: /stm32-from_zero_to_rtos-2_timers/
notely:
  - 
  - 
  - 
wp_noextrenallinks_mask_links:
  - 0
  - 0
  - 0
ratings_users:
  - 5
  - 5
  - 5
ratings_score:
  - 25
  - 25
  - 25
ratings_average:
  - 5
  - 5
  - 5
dsq_thread_id:
  - 2726308849
categories:
  - С нуля
  - С нуля до RTOS
tags:
  - STM32
  - электроника
---
В STM32 есть множество очень удобных и гибких в настройке таймеров. Даже у самого младшего микроконтроллера (STM32F030F4P6) есть 4 таких таймера.

<!--more-->

# <span style="font-size: 30px; line-height: 1.3;">8. Настроим проект — добавим нужные файлы</span>

Чтобы использовать таймер, нам потребуется подключить файл библиотеки периферии stm32f10x\_tim.c. Точно так же, правой кнопкой щёлкаем в Workspace (окно слева) по группе StdPeriphLib, Add –> Add files, файл LibrariesSTM32F10x\_StdPeriph\_Driversrcstm32f10x\_tim.c.

Ещё нужно включить использование заголовка к этому файлу. Открываем stm32f10x\_conf.h (правой кнопкой по названию этого файла в коде, &#171;Open stm32f10x\_conf.h&#187;. Раскомментируем строчку #include &#171;stm32f10x_tim.h&#187;.

## 9. Добавим таймер

Задержка пустым циклом — это кощунство, тем более на таком мощном кристалле как STM32, с кучей таймеров. Поэтому сделаем эту задержку с помощью таймера.

В STM32 есть разные таймеры, отличающиеся набором свойств. Самые простые — Basic timers, посложнее — General purpose timers, и самые сложные — Advanced timers. Простые таймеры ограничиваются просто отсчётом тактов. В более сложных таймерах появляется [ШИМ](http://catethysis.ru/stm32-%e2%86%92-%d1%82%d0%b0%d0%b9%d0%bc%d0%b5%d1%80%d1%8b-%e2%86%92-%d1%88%d0%b8%d0%bc/ "STM32 → таймеры → ШИМ"). Самые сложные таймеры, к примеру, могут сгенерировать 3–фазный ШИМ с прямыми и инверсными выходами и дедтаймом. Нам хватит и простого таймера, под номером 6.

### Немного теории

Всё, что нам требуется от таймера — досчитывать до определённого значения и генерировать прерывание (да, мы ещё и научимся использовать прерывания). Таймер TIM6 тактируется от системной шины, но не напрямую а через прескалер — простой программируемый счётчик–делитель (подумать только, в СССР выпускались специальные микросхемы–счётчики, причём программируемые были особым дефицитом — а теперь я говорю о таком счётчике просто между делом). Прескалер можно настраивать на любое значение от 1 (т.е. на счётчик попадёт полная частота шины, 24МГц) до 65536 (т.е. 366 Гц).

Тактовые сигналы в свою очередь, увеличивают внутренний счётчик таймера, начиная с нуля. Как только значение счётчика доходит до значения ARR — счётчик переполняется, и возникает соответствующее событие. По наступлению этого события таймер снова загружает 0 в счётчик, и начинает считать с нуля. Одновременно он может вызвать прерывание (если оно настроено).
  
<img alt="" src="http://static.catethysis.ru/files/STM32_lessons_TIM_overflow_irq.png" width="544" height="283" />

На самом деле процесс немного сложнее: есть два регистра ARR — внешний и внутренний. Во время счёта текущее значение сравнивается именно со внутренним регистром, и лишь при переполнении внутренний обновляется из внешнего. Таким образом, можно безопасно менять ARR во время работы таймера — в любой момент.

### Код

Код будет очень похож на предыдущий, т.к. инициализация всей периферии происходит однотипно — за тем лишь исключением, что таймер TIM6 висит на шине APB1. Поэтому включение таймера: RCC\_APB1PeriphClockCmd(RCC\_APB1Periph_TIM6, ENABLE);

Теперь заводим структуру типа TIM\_TimeBaseInitTypeDef, инициализируем её (TIM\_TimeBaseStructInit), настраиваем, передаём её в функцию инициализации таймера (TIM\_TimeBaseInit) и наконец включаем таймер (TIM\_Cmd).

    TIM_TimeBaseInitTypeDef TIM_InitStructure;  // Заводим структуру
    TIM_TimeBaseStructInit(&TIM_InitStructure); // Инициализация структуры
    TIM_InitStructure.TIM_Prescaler = 24000;    // Предделитель
    TIM_InitStructure.TIM_Period = 1000;        // Период таймера
    TIM_TimeBaseInit(TIM6, &TIM_InitStructure); // Функция настройки таймера
    TIM_Cmd(TIM6, ENABLE);                      // Включение таймера

Что за магические числа? Как мы помним, на шине присутствует тактовая частота 24МГц (при наших настройках проекта). Настроив предделитель таймера на 24000, мы поделим эту частоту на 24 тысячи, и получим 1кГц. Именно такая частота попадёт на вход счётчика таймера.
  
Значение же в счётчике — 1000. Значит, счётчик переполнится за 1000 тактов, т.е. ровно за 1 секунду.

После этого у нас действительно появляется работающий таймер. Но это ещё не всё.

## 10. Разберёмся с прерываниями

Окей, прерывания. Для меня когда–то (во времена PIC) они были тёмным лесом, и я старался вообще их не использовать — да и не умел, на самом деле. Однако, в них заключена сила, игнорировать которую вообще недостойно. Правда, прерывания в STM32 — ещё более сложная штука, особенно механизм их вытеснения; но об этом позже.

Как мы заметили раньше, таймер генерирует прерывание в момент переполнения счётчика — если включена вообще обработка прерываний этого прибора, конкретно это прерывание включено и сброшено предыдущее такое же. Анализируя эту фразу, понимаем что нам нужно:

  1. Включить вообще прерывания таймера TIM6;
  2. Включить прерывание таймера TIM6 на переполнение счётчика;
  3. Написать процедуру–обработчик прерывания;
  4. После обработки прерывания сбросить его.

Поехали.

### Включение прерываний

Честно говоря, тут вообще ничего сложного. Первым делом включаем прерывания TIM6: NVIC\_EnableIRQ(TIM6\_DAC_IRQn); Почему такое название? Потому что в ядре STM32 прерывания от TIM6 и от ЦАП имеют одинаковый номер. Не знаю, почему так сделано — экономия, нехватка номеров или просто какая–то наследная штука — в любом случае, никаких проблем это не принесёт, потому что в этом проекте не используется ЦАП. Даже если в нашем проекте использовался бы ЦАП — мы могли бы при входе в прерывание узнавать, кто конкретно его вызвал. Практически все другие таймеры имеют единоличное прерывание.

Настройка события–источника прерываний: TIM\_ITConfig(TIM6, TIM\_DIER\_UIE, ENABLE); — включаем прерывание таймера TIM6 по событию TIM\_DIER_UIE, т.е. событие обновления значения ARR. Как мы помним из картинки, это происходит одновременно с переполнением счётчика — так что это именно то событие, которое нам нужно.

На текущий момент код таймерных дел таков:

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
    
    TIM_TimeBaseInitTypeDef TIM_InitStructure;
    TIM_TimeBaseStructInit(&TIM_InitStructure);
    TIM_InitStructure.TIM_Prescaler = 24000;  
    TIM_InitStructure.TIM_Period = 1000; 
    TIM_TimeBaseInit(TIM6, &TIM_InitStructure);  
    TIM_Cmd(TIM6, ENABLE);
    
    NVIC_EnableIRQ(TIM6_DAC_IRQn);  
    TIM_ITConfig(TIM6, TIM_DIER_UIE, ENABLE);

### Обработка прерываний

Сейчас запускать проект нельзя — первое же прерывание от таймера не найдёт свой обработчик, и контроллер повиснет (точнее, попадёт в обработчик HARD_FAULT, что по сути одно и то же). Нужно его написать.

#### Немного теории

Он должен иметь совершенно определённое имя, void TIM6\_DAC\_IRQHandler(void). Это имя, так называемый вектор прерывания, описано в файле startup (в нашем проекте это startup\_stm32f10x\_md_vl.s — можете сами увидеть, 126 строка). На самом деле вектор — это адрес обработчика прерывания, и при возникновении прерывания ядро ARM лезет в начальную область (в которую транслирован файл startup — т.е. его местоположение задано совершенно жёстко, в самом начале флеш–памяти), ищет там вектор и переходит в нужное место кода.

#### Проверка события

Первое что мы должны сделать при входе в такой обработчик — проверить, какое событие вызвало прерывание. Сейчас у нас всего одно событие, а в реальном проекте на одном таймере вполне могут быть несколько событий. Поэтому проверяем событие, и выполняем соответствующий код.

В нашей программе эта проверка будет выглядеть так: if (TIM\_GetITStatus(TIM6, TIM\_IT\_Update) != RESET) — всё понятно, функция TIM\_GetITStatus проверяет наличие указанного события у таймера, и возвращает 0 или 1.

#### Очистка флага UIF

Второй шаг — очистка флага прерывания. Вернитесь к картинке: самый последний график UIF это и есть флаг прерывания. Если его не очистить, следующее прерывание не сможет вызваться, и контроллер опять упадёт в HARD_FAULT (да что же такое!).

### Выполнение действий в прерывании

Будем просто переключать состояние светодиода, как и в первой программе. Разница в том, что теперь наша программа делает это более сложно! На самом деле, так писать гораздо правильнее.

    if(state)
      GPIO_WriteBit(GPIOC, GPIO_Pin_8, Bit_SET);
    else
      GPIO_WriteBit(GPIOC, GPIO_Pin_8, Bit_RESET);
    state = 1 - state;

Используем глобальную переменную int state=0;

## 11. Весь код проекта с таймером

    #include "stm32f10x_conf.h"
    
    int state=0;
    
    void TIM6_DAC_IRQHandler(void)
    {
      if (TIM_GetITStatus(TIM6, TIM_IT_Update) != RESET)
      {
        TIM_ClearITPendingBit(TIM6, TIM_IT_Update);
        if(state)
          GPIO_WriteBit(GPIOC, GPIO_Pin_8, Bit_SET);
        else
          GPIO_WriteBit(GPIOC, GPIO_Pin_8, Bit_RESET);
        state = 1 - state;
      }
    }
    
    void main()
    {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
    
      GPIO_InitTypeDef GPIO_InitStructure;
      GPIO_StructInit(&GPIO_InitStructure);
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
      GPIO_Init(GPIOC, &GPIO_InitStructure);
    
      GPIO_WriteBit(GPIOC, GPIO_Pin_8, Bit_SET);
    
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
    
      TIM_TimeBaseInitTypeDef TIM_InitStructure;
      TIM_TimeBaseStructInit(&TIM_InitStructure);
      TIM_InitStructure.TIM_Prescaler = 24000;  
      TIM_InitStructure.TIM_Period = 1000; 
      TIM_TimeBaseInit(TIM6, &TIM_InitStructure);  
      TIM_Cmd(TIM6, ENABLE);
    
      NVIC_EnableIRQ(TIM6_DAC_IRQn);  
      TIM_ITConfig(TIM6, TIM_DIER_UIE, ENABLE);  
    
      while(1)
      {
      }
    }

<a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/http://static.catethysis.ru/files/STM32_Projects_2_TIM.rar" >Архив</a> с проектом таймера.

<p style="text-align: left;">
  Ну и к слову, таймер умеет <a title="STM32 → Порты GPIO" href="http://catethysis.ru/stm32-%e2%86%92-%d0%bf%d0%be%d1%80%d1%82%d1%8b-gpio/">переключать ногу</a> и сам, без прерываний и ручной обработки. Это будет наш третий проект.
</p>

Весь цикл:
  
[1. Порты ввода–вывода](http://catethysis.ru/index.php/stm32-from_zero_to_rtos-1_gpio/ "STM32 — с нуля до RTOS. 1: Порты ввода–вывода")
  
2. Таймер и прерывания
  
[3. Выходы таймера](http://catethysis.ru/index.php/stm32-from_zero_to_rtos-3_timer_outputs/ "STM32 — с нуля до RTOS. 3: Выходы таймера")
  
[4. Внешние прерывания и NVIC](http://catethysis.ru/index.php/stm32-from_zero_to_rtos-4_exti_nvic/ "STM32 — с нуля до RTOS. 4: Внешние прерывания и NVIC")
  
[5. Ставим FreeRTOS](http://catethysis.ru/index.php/freertos_stm32f100_iar/ "Установка FreeRTOS на STM32F100 в IAR")