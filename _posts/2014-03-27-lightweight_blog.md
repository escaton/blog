---
id: 1161
title: Легковесный блог
date: 2014-03-27T01:29:02+00:00
author: catethysis
layout: post
guid: http://catethysis.ru/?p=1161
permalink: /lightweight_blog/
notely:
  - 
  - 
  - 
wp_noextrenallinks_mask_links:
  - 0
  - 0
  - 0
ratings_users:
  - 1
  - 1
  - 1
ratings_score:
  - 5
  - 5
  - 5
ratings_average:
  - 5
  - 5
  - 5
dsq_thread_id:
  - 2733279119
categories:
  - JavaScript
tags:
  - javascript
---
<img class="alignnone" src="http://static.catethysis.ru/files/md_blog.png" alt="" width="1491" height="888" />

Связка WordPress+nginx — не слишком хорошая штука, как в плане удобства, так и в плане скорости работы. Когда скорость ответа сервера (только ответа, ещё до начала отправки страницы) дошла до 1.5 секунд, я окончательно решил что нужно что–то менять. Перспектива лезть в дебри движка вордпресса и по локти испачкаться в PHP меня совершенно не прельщала, и я нашёл очень удобный выход из положения — Markdown–блог.

<!--more-->

# Архитектура {#–}

Применён паттерн &#171;содержание–представление&#187;. Сначала я использовал модуль <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/testdouble/grunt%E2%80%93markdown%E2%80%93blog" >grunt–markdown–blog</a>, но его некоторая кривость и необщительность разработчиков сделали своё дело — я написал свой модуль. Конечно, во многом я основывался на архитектуре grunt–markdown–blog, потому что она действительно весьма удобна.

## Содержимое/написание {#–}

Каждая статья пишется простым текстом с **markdown**–разметкой, сохраняется в виде .md–файла в директории /posts/. В начале файла находится **YAML**–блок (отделённый тремя тире от текста), в котором описаны:

  * заголовок поста
  * дата создания
  * теги

## Вид {#–}

В директории /templates/ лежат шаблоны всех типов страниц:

  * **post.us** — страница поста
  * **index.us** — главная (список постов)
  * **archive.us** — архив по тегу или по месяцам

Общий дизайн задаётся шаблоном **wrapper.us**, в который &#171;оборачиваются&#187; все страницы — он сделан довольно простым, без лишнего оформления. Для комментариев подключен блок от <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/http://disqus.com/" >disqus.com</a> — и это единственный &#171;плагин&#187; на странице.

## Обработка {#–}

Написан node.js–скрипт, который загружает все файлы из директории /posts/ и прогоняет их через процессор постов: выделяет YAML–блок метаописания поста (с помощью <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/nodeca/js%E2%80%93yaml" >js–yaml</a>) и Markdown–блок текста, который превращается в html отличной библиотекой <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/chjj/marked" >Marked</a>. После создания html немного правлю типографику — заменяю &#171;минусы&#187; на нормальные тире.

### Подсветка кода {#–}

Поскольку в моих постах часто приведены куски кода, необходимо как–то их оформлять. Для этого я, конечно, использую <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/http://highlightjs.org/" >highlight.js</a>.

<address>
  В WordPress это было сущей мукой — необходимо было переключиться в режим html, руками ввести там теги pre и code, указать ему нужный класс с языком, и следить чтобы ничего не развалилось. А разваливалось часто, например если во вставленном js–коде был блок CDATA.
</address>

Раньше я применял стандартный способ его использования — просто подключал к странице hljs.js–скрипт, который по событию onLoad автоматически распознавал блоки кода и оформлял их нужным образом. Однако из–за этого на мгновение код отображался <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/http://en.wikipedia.org/wiki/Flash_of_unstyled_content" >неоформленным</a>, и это мигание было просто неэстетичным. К тому же эта работа выполнялась каждый раз при загрузке страницы, что нельзя назвать экономным расходованием ресурсов. Поэтому я включил в скрипт модуль hljs, который оформляет код ещё на этапе &#171;сборки&#187;.

Также, файл hljs.css просто огромен, и содержит довольно много лишнего (я пишу только на c и js) — поэтому я выделил из него только что, что реально мне нужно и включил это в wrapper.us инлайн.

<address>
  Была небольшая проблема с двойным (на этапе marked и на этапе hljs) преобразованием специальных символов, из–за которого они превращались в escape–последовательности прямым текстом. К сожалению, ни одна из этих библиотек не позволяет отключить такое преобразование, и чтобы не лезть в их код — я сделал функцию repair, которая делает обратное преобразование. Выглядит как костыль, но похоже что по–другому не сделать.
</address>

<address>
  Ещё одна проблема hljs.js именно в виде node–модуля — не работает язык C. Приходится вручную выбирать C#. В client–side версии такой проблемы нет.
</address>

### Шаблонизация {#–}

После этого обрабатываем метаописание — добавлям заголовок, теги, складываем пост в массив index и массив тегов. Теперь, наконец, применяем шаблоны к этим кускам html–кода, оборачиваем враппером, и сохраняем всё полученное в файлы. Весь скрипт довольно прост и занимает всего 40 строк в write–only стиле.

## Grunt.js {#grunt–js}

Дальше в дело вступает Grunt.js. Точнее, весь описанный процесс сборки уже являлся первым шагом в файле Gruntfile.js, а следом за ним работает компрессор HTML. Это стандартный гугловский компрессор, который сжимает html–код, а благодаря настройкам compressCss и compressJs — ещё и стили со скриптами.

Окончательное сжатие в gzip выполняет уже nginx.

Всё это обёрнуто в grunt–цель &#171;watch&#187;, и я получаю автопересборку после каждого изменения любых исходных файлов.

* * *

Так я добился сразу многих плюсов:

  * Очень простое создание и редактирование постов
  * Легко вставлять блоки кода, сразу с указанием языка для правильной подсветки
  * Страницы отдаются чисто nginx–ом из памяти (настроено кэширование)
  * Сверхбыстрая загрузка (Google PageSpeed оценивает в 99 баллов из ста)
  * Возможность размещения на любом хостинге
  * Лёгкое создание бекапа, которое можно автоматизировать