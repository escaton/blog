---
id: 218
title: Promise в Node.js (библиотека Vow)
date: 2013-09-20T06:41:51+00:00
author: catethysis
layout: post
guid: http://catethysis.ru/?p=218
permalink: /node-js-vow/
ratings_users:
  - 3
  - 3
  - 3
ratings_score:
  - 11
  - 11
  - 11
ratings_average:
  - 3.67
  - 3.67
  - 3.67
wp_noextrenallinks_mask_links:
  - 0
dsq_thread_id:
  - 2726263370
categories:
  - Модули node.js
tags:
  - node.js
  - модули
---
В node.js (да и в самом javacript) делается ставка на асинхронность. Поэтому перебежчикам из других языков поначалу ход выполнения программы может показаться странным и даже нелогичным. Ещё бы — любая вызванная функция выполняется в фоновом потоке и сразу после вывода отдаёт управление следующей строчке кода. Справедливости ради скажем, что иначе и быть не могло &#8212; javascript пока медленнее чем любой native язык, поэтому распараллеливание обработки конечно ему просто необходимо.

Однако, иногда такое поведение вообще лишает возможности правильно работать с функциями, возвращающими какие-то нужные значения — особенно медленными. Возможна также другая ситуация — много вложенных вызовов функций, и код превращается в лесенку — а если говорить честно, то получается настоящий спагетти–код. Конечно, такого надо всячески избегать.

<!--more-->

Чтобы решить все эти проблемы, в javascript существует механизм promise. По сути — это просто установка семафора окончания фонового потока. Вот как это работает:

  1. Сначала мы объявляем (создаём) этот семафор.
  2. ПОСЛЕ завершения действия фонового потока, мы включаем семафор.
  3. В совершенно произвольном месте кода мы создаём обработчик семафора.

Подробнее про различные классы промизов (и прочие особенности) можно почитать <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/promises-aplus/promises-spec"  target="_blank">тут</a>, однако пока обойдёмся без такого погружения.

По некоторым соображениям поддержка promise в node.js была убрана, однако появились сторонние реализации — библиотеки q, when и так далее. По результатам <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/http://habrahabr.ru/post/174339/"  target="_blank">бенчмарка</a> самым быстрым был признан Vow — его и рассмотрим.

Страница на <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/dfilatov/jspromise"  target="_blank">github</a>, страница на <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://nodejsmodules.org/pkg/vow"  target="_blank">nodejsmodules</a>.

Установка пакета Vow:

    npm install vow

1. Создание семафора:

<pre>var vow = require('vow');
var semaphore1 = vow.promise();
var semaphore2 = vow.promise();</pre>

2. Включение семафора:

<pre>//В одной асинхронной функции
semaphore1.fulfill(0);

//В другой асинхронной функции
semaphore2.fulfill(0);</pre>

3. Обработка семафора:

<pre>vow.all([semaphore1,semaphore2]).then(function(value) {
  //обработка
});</pre>

Ничего сложного в этом нет. Надо сказать, что в функции включения семафора можно передавать некое значение, или объект. Тогда функцию then лучше заменить на spread — она более удобно представляет значения промизов в обработчик. Поясню на примере.

Типичное для меня применение промизов — параллельная загрузка файла-шаблона и [выборка из базы данных](http://catethysis.ru/?p=142 "Работа с MySQL в Node.js") значений для заполнения этого шаблона. Тогда с помощью промизов всё можно сделать так:

<pre>var file_read = vow.promise();
var sql_select = vow.promise();

fs.readFile('template.htm', function (err,page){ file_read.fulfill(String(page)); });

connection.query('select * form table;', function(fields, result) {
    sql_select.fulfill(photos);
});

vow.all([file_read, sql_select]).spread(function (page, photos) {
    //конечно, за кадром осталась работа с шаблоном и данными - она не нужна
    //для демонстрации. Примем, что мы как бы просто склеиваем две этих строки.
    res.end(page+photos);
});</pre>

Цель достигнута — загрузка файла и выборка значений происходят одновременно, и общее время обработки страницы сокращается. Раз уж затронули этот вопрос, надо сказать что не стоит загружать файл шаблона каждый раз при запросе. Нужно сложить его в переменную, либо сделать мета-функцию, которая бы проверяла наличие файла в таком кеше, и при надобности загружала бы его.

## Более глубокое использование vow.js

Выше был рассмотрен самый простой случай использования vow.js, продвинемся немного глубже. У промизов есть два метода завершения &#8212; fulfill(), который сигнализирует об успешном завершении, и reject() &#8212; о неуспешном. Их &#171;ИЛИ&#187; объединение &#8212; сигнал resolved() . Также промиз может уведомить материнский процесс о чём-то, не сигнализируя о завершении, для этого используется метод notify. Использование всех этих методов позволяет гибко выстраивать алгоритм работы с ними, не прибегая к передаче какой-то информации в теле ответа промиза &#8212; и не тратя время и код на разбор этой информации в материнском процессе.

## Методы работы с сигналами промизов в vow.js.

Для &#171;измерения&#187; сигнала &#8212; функция valueOf(), которая отвечает fulfilled, rejected или undefined если работа потока ещё не завершена. Аналоги &#8212; функции isFulfilled(), isRejected(), и объединяющая их по принципу &#171;ИЛИ&#187; функция isResolved().

switch-функция then(). В зависимости от ответа промиза вызывает одну из трёх внутренних функций &#8212; onFulfilled (){}, onRejected(){}, или onNotified(){}. Сокращает код да и вообще делает его немного читабельнее. Похожие на неё функции fail(), которая вызывает внутреннюю функцию в случае ответа reject, и always() &#8212; которая срабатывает на ответ resolved, т.е. fulfilled || rejected.

progress() &#8212; удобная функция, реагирующая на сигнал notify. Позволяет отображать, например, прогресс выполнения промиза &#8212; да и вообще всё что вы передадите в качестве уведомления.

Вместо функции all можно использовать функцию all_resolved, чтобы выполнять действия только если все промизы успешно разрешились.