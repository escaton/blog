---
id: 1831
title: Github
date: 2014-07-01T01:56:09+00:00
author: Catethysis
layout: post
guid: http://catethysis.ru/?p=1831
permalink: /github-stm32-code-libraries/
ratings_users:
  - 1
ratings_score:
  - 5
ratings_average:
  - 5
wp_noextrenallinks_mask_links:
  - 0
dsq_thread_id:
  - 2808045595
categories:
  - Без рубрики
---
Гитхаб &#8212; это платформа &#171;социального кодинга&#187;: удобное место для совместной работы над open-source проектами, в котором упор сделан на лёгкость правок и дополнений, а самое главное &#8212; клонирования чужих репозиториев, создание форков. К примеру, вы видите хороший репозиторий, в котором работают над каким-то интересным вам проектом. Однако, вам от этого проекта нужна только часть, или вы хотите на базе уже созданных функций сделать свои собственные &#8212; короче, хотите скопировать этот репо и продолжить работу над ним, не портя основной репо. Тогда вы делаете форк, клонируете его себе на компьютер и дальше работаете с ним &#8212; создаёте изменения, отправляете на сервер, но уже в рамках своего репозитория.

На гитхабе очень удобно редактировать код, а также смотреть старые версии проекта.

<!--more-->

## Коммиты

Изменяя код, нужно делать коммиты &#8212; этакие этапы работы. Состояние кода на момент коммита сохраняется на сервере, и в любой момент вы можете откатиться к этому коммиту, если что-то пошло не так.

Каждый коммит необходимо сопровождать комментарием, описывающим проделанные изменения: из этого автоматически следует, что коммит &#8212; это некая завершённая маленькая часть работы. Не имеет смысла коммитить каждое изменение, к примеру простое объявление новой переменной &#8212; хотя некоторые так делают, и это называется атомарными коммитами. При таких коммитах история изменений быстро растёт, и становится проблематично быстро искать нужный этап при необходимости отката назад.

## Теги

Более крупные этапы работы, т.е. законченные версии проекта, нужно помечать тегом. Самое логичное название для тега &#8212; номер версии. Теги удобны своей чёткой структурой (если придерживаться этой структуры!) и возможностью быстро посмотреть код любой версии проекта.

Кстати, я советую использовать версионирование в стиле SemVer: версия = мажор.минор.патч.

  1. Мажорная версия меняется редко, каждый раз когда вы ломаете API &#8212; т.е. форматы функций, структуры данных
  2. Минорная версия меняется чаще, каждый раз когда вы добавляете новые функции, не ломая совместимость
  3. Номер патча увеличивается при каждом изменении &#8212; то есть, при каждом коммите или чуть реже.

## Бранчи

Очень, очень часто бывает такое, что ваши правки влекут за собой масштабные изменения &#8212; это добавление каких-то новых функций с необходимостью переделки большого количества кода, структур данных, других зависимых функций &#8212; или даже банальный рефакторинг. Делать это в рамках текущей копии кода проекта очень опасно &#8212; можно нечаянно всё сломать, хотя можно откатиться к старому коммиту. Чаще возникает ситуация такая (особенно на работе): собрался рефакторить, всё красиво разложил, развесил функции по верёвочкам, всё перед глазами &#8212; красота, можно начинать рефакторинг. И тут прибегают люди, кричат: &#171;в прошивке глюки, срочно надо всё ремонтировать!&#187;. И что делать? Всё разложенное не соберёшь обратно быстро, откатываться на старый коммит жалко &#8212; столько работы пропадёт, по-старинке копировать код в отдельную папочку как-то глупо &#8212; зачем мы тогда Git используем?

Тут на помощь приходят бранчи, т.е. ветки. Перед началом масштабной работы, изменений которые ломают всю совместимость &#8212; делаете ответвление от основного дерева проекта. Создаётся копия текущего состояния проекта, так назваемый бранч &#8212; теперь можно вести работу в нём. Любые изменения в бранче не влияют на основную ветку, и когда приходится срочно возвращаться к основной ветке &#8212; это делается просто командой переключения. Подправив проект в основной ветке и закоммитив изменения, переключаетесь обратно и продолжаете ваять нетленку в боковой ветке.

Закончив рефакторинг или что-то ещё что вы делали в бранче &#8212; необходимо влить его обратно в основную ветку. Это несложная, но довольно муторная задача &#8212; нужно вручную отследить все изменения, произошедшие за это время в основной ветке, и добавить их в эту дополнительную. Если же изменений не было &#8212; просто заменяем старые файлы на новые из бранча.

## Слияние

Если над кодом работает несколько человек, один и тот же файл может быть изменён одновременно всеми этими программистами &#8212; один добавил фичу А, другой &#8212; фичу Б, а на сервере вообще лежит старая версия без этих фич &#8212; ни у кого нет полной версии с обоими фичами. Как быть в такой ситуации? Нужно &#171;слить&#187; все изменения. Рассмотрим по очереди.

  1. На сервере лежит нулевая версия кода, два программиста скачали её себе (в свой локальный репозиторий) и вносят правки.
  2. Первый прогер написал фичу А, делает коммит/пуш, заменяет старую версию на сервере на новую версию кода с фичей А.
  3. Второй прогер добавил фичу Б, пытается её закоммитить &#8212; но сервер не даёт этого сделать, потому что видит несовпадение версий.
  4. Теперь второй прогер должен апдейтить свой локальный репозиторий, забрать с сервера изменённый файл &#8212; но теперь будет ругаться уже клиент git на его компьютере, потому что видит что старый файл был изменён прогером и не даёт затереть эти изменения.
  5. Второй прогер должен запустить мёржилку &#8212; в ручном режиме найти изменения первого прогера (фичу А) и добавить их в свой код с уже написанной фичей Б. К счастью, процесс этот довольно прост благодаря функции diff, которая подсвечивает все изменения. Это называется &#171;слияние&#187; или &#171;сливание&#187;.
  6. Добавив все изменения, он подтверждает апдейт, и получает у себя самую свежую полную версию с обоими фичами. Теперь он делает апдейт, на сервер уезжает эта полная версия.
  7. Первый прогер делает апдейт у себя, получает полную версию. Обе фичи теперь разъехались по всем репозиториям, серверному и двум локальным.

Всё это &#8212; несложный, хотя иногда и довольно муторный процесс, но он даёт возможность работать над одним кодом совместно, увеличивая эффективность. Самое главное &#8212; апдейтиться как можно чаще, не оставляя процесс на самотёк: иначе вы будете работать с довольно старой версией кода, а при апдейте вам придётся, возможно, просидеть не один час над ручным слиянием очень разного кода.

И самое главное &#8212; не коммитьте плохой код, особенно ломающий нормальную сборку проекта. В больших компаниях человека, сломавшего билд, подвергают общественному порицанию <img src="http://catethysis.ru/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" />