---
id: 2654
title: BitBanding в ARM Cortex — доступ к отдельным битам регистров
date: 2015-09-10T02:56:54+00:00
author: Catethysis
layout: post
guid: http://catethysis.ru/?p=2654
permalink: /bitbanding_arm_cortex/
wp_noextrenallinks_mask_links:
  - 0
ratings_users:
  - 2
ratings_score:
  - 10
ratings_average:
  - 5
dsq_thread_id:
  - 4114976809
categories:
  - STM32
  - Без рубрики
---
В ядрах ARM Cortex есть удобный способ для доступа к отдельным битам регистров. Каждый бит получает свой виртуальный регистр, в который можно записать 0 или 1.

Номера регистров битбэндинга формируются так:

<pre>0x42000000 + (регистр - 0x40000000) * 0x20 + номер_бита * 4.</pre>

**Использование битбэндинга**

Рассмотрим пример. Вам нужно выполнить операцию

<pre><code class="cpp">GPIOC-&gt;CRH |= GPIO_CRH_MODE9_0;</code></pre>

Эта операция в ассемблерном коде занимает 6 полуслов = 12 байт:

<pre><code class="armasm">0x4815          LDR.N    R0, [PC, #0x54]
0x6800          LDR      R0, [R0]
0xf050 0x0010   ORRS.W   R0, R0, #16
0x4913          LDR.N    R1, [PC, #0x4C]
0x6008          STR      R0, [R1]</code></pre>

Теперь то же самое через битбэндинг. Требуется установить четвёртый бит регистра № 0x40011004, вычисляем адрес бита: 0x42000000 + (0x40011004 &#8212; 0x40000000) \* 0x20 + 4 \* 4 = 0x42220090. Устанавливаем бит (достаточно записать 1 в этот регистр):

<pre><code class="cpp">*(uint32_t*)0x42220090 = 1;</code></pre>

Ассемблерный код теперь занимает в два раза меньше места:

<pre><code class="armasm">0x2001          MOVS     R0, #1
0x4914          LDR.N    R1, [PC, #0x50]
0x6008          STR      R0, [R1]</code></pre>

Для удобства вычислений я сделал [онлайн-калькулятор битбэндинга](http://catethysis.ru/calculators/ "Калькуляторы"), он даже сразу генерирует код.