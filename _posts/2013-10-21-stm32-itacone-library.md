---
id: 490
title: 'Библиотека для STM32 &#8212; itacone'
date: 2013-10-21T07:26:11+00:00
author: catethysis
layout: post
guid: http://catethysis.ru/?p=490
permalink: /stm32-itacone-library/
ratings_users:
  - 1
  - 1
  - 1
ratings_score:
  - 5
  - 5
  - 5
ratings_average:
  - 5
  - 5
  - 5
notely:
  - 
  - 
  - 
dsq_thread_id:
  - 2726264101
categories:
  - Библиотеки
  - Исследования
tags:
  - STM32
  - электроника
---
Библиотека StdPeriph от ST окончательно перестала удовлетворять меня своим неудобным синтаксисом и тем, что на все эти настройки тратится много времени. Стыдно сказать, у меня даже есть файл-шаблон, где сложены все основные примеры настройки нужной мне периферии &#8212; но конечно, назвать это профессионализмом нельзя. Поэтому я пишу библиотеку **itacone **для упрощения всех этих взаимодействий.

<!--more-->

Репозиторий на <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/Catethysis/itacone"  target="_blank">GitHub &#8212; itacone</a>.

Я попытался совместить в ней простоту использования функций (прости, господи) Ардуино, немного синтаксического сахара в стиле javascript и конечно, не забыл о читаемости кода и удобстве применения.

Вся платформо-зависимая часть кода (адреса портов, разнообразие периферии) вынесена в отдельный файл конфигурации. В свою очередь, различные конфигурации подключаются в зависимости от имени ядра, объявленного в начале файла. Поэтому для перехода на другое ядро будет достаточно его объявить &#8212; и всё произойдёт автоматически.

Все нужные переменные уже доступны &#8212; подключаете модуль itacone.h и имеете переменные для всей периферии.
  
На текущий момент полностью сделан [модуль GPIO](http://catethysis.ru/stm32-%e2%86%92-%d0%bf%d0%be%d1%80%d1%82%d1%8b-gpio/ "STM32 → Порты GPIO"). Он даёт возможность настраивать пины на вход/выход, писать и читать из них.

<span style="line-height: 1.5;">Допустим, вы хотите помигать штатным светодиодом на плате STM32Discovery. Для этого достаточно написать:</span>

<pre>PC8.mode(OUTPUT).low();
while(1) PC8.toggle().delay(300);</pre>

И это всё! Просто, правда?

Есть все нужные функции, а для часто используемых функций (чтение/запись в пин) предусмотрены короткие легкозапоминаемые ссылки. Распишу подробнее.

## Модуль GPIO

Сначала &#8212; настройка порта. Реализованы все возможные режимы его использования.

#### <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/Catethysis/itacone#%D0%9F%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8-%D0%B2%D1%85%D0%BE%D0%B4%D0%B0%D0%B2%D1%8B%D1%85%D0%BE%D0%B4%D0%B0"  name="Параметры-настройки-входавыхода"></a>Параметры настройки входа/выхода

OUTPUT_PP &#8212; выход в режиме пуш-пулл.
  
OUTPUT_OD &#8212; выход с открытым коллектором.
  
OUTPUT\_AF\_PP &#8212; выход периферии в режиме пуш-пулл.
  
OUTPUT\_AF\_OD &#8212; выход периферии с открытым коллектором.
  
INPUT_AN &#8212; вход для АЦП.
  
INPUT_FL &#8212; &#171;плавающий&#187; вход, или третье (высокоимпедансное) состояние.
  
INPUT_PU &#8212; вход со слабой подтяжкой к &#171;+&#187;.
  
INPUT_PD &#8212; вход со слабой подтяжкой к &#171;-&#171;.

#### <a target="_blank" rel="nofollow" href="http://catethysis.ru/goto/https://github.com/Catethysis/itacone#%D0%9F%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D0%B8-%D0%B2%D1%8B%D1%85%D0%BE%D0%B4%D0%B0"  name="Параметры-скорости-выхода"></a>Параметры скорости выхода

SPEED_2 &#8212; максимальная скорость переключения пина &#8212; 2МГц.
  
SPEED_10 &#8212; максимальная скорость переключения пина &#8212; 10МГц.
  
SPEED_50 &#8212; максимальная скорость переключения пина &#8212; 50МГц.

Далее &#8212; вывод в пин. Для этого &#8212; функция pin.out(LOW|HIGH) а также более простые pin.high(), pin.low() и pin.toggle().

Чтение состояния пина &#8212; так же просто: функция pin.in().

Удобной особенностью является то, что можно строить цепочки запросов:

<pre>PC8. mode(OUTPUT). high() .delayMs(300). low(). delayMs(500). mode(INPUT). read(&a). delayMs(1000). read();</pre>

В этом примере мы назначаем пин PC8 &#171;выходом&#187;, на 300 миллисекунд выводим в него &#171;1&#187;, потом на 500 миллисекунд выводим &#171;0&#187;, переводим пин во &#171;вход&#187; и читаем его значение в переменную a, а через секунду &#8212; снова читаем состояние и возвращаем его в переменную b.

Это удобно, например, для выполнения в цикле.

## Модуль misc

В этом модуле собраны разные вспомогательные функции, необходимые для работы библиотеки, а также пользовательские функции, не вошедшие в другие модули.

Среди них &#8212; функция паузы delayMs(ms).

Также есть функции для получения [уникального номера микроконтроллера](http://catethysis.ru/stm32-%e2%86%92-unique-id/ "STM32 → Unique ID"), зашитого внутри кристалла при производстве. Это три функции Unique\_ID\_Low, Unique\_ID\_Mid и Unique\_ID\_Hig, возвращающие 32-битное значение (компоненты 96-битного номера устройства) и две функции Unique\_ID\_Low0 и Unique\_ID\_Low1, возвращающие две 16-битные компоненты номера ID_Low. Полный номер устройства &#8212; это три значения Low, Mid и Hig, однако для большинства применений достаточно первого из них, и для удобства он разделён на две 16-битных части.

В ближайшем будущем планирую также добавить [модуль таймера](http://catethysis.ru/stm32-%e2%86%92-%d1%82%d0%b0%d0%b9%d0%bc%d0%b5%d1%80%d1%8b-%e2%86%92-%d1%88%d0%b8%d0%bc/ "STM32 → таймеры → ШИМ") и [USART](http://catethysis.ru/stm32-%e2%86%92-uart-usart/ "STM32 → UART / USART").