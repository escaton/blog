---
id: 905
title: STM32 → Порты GPIO
date: 2013-12-26T18:10:32+00:00
author: catethysis
layout: post
guid: http://catethysis.ru/?p=905
permalink: /stm32-gpio/
notely:
  - 
  - 
  - 
wp_noextrenallinks_mask_links:
  - 0
  - 0
  - 0
ratings_users:
  - 5
  - 5
  - 5
ratings_score:
  - 25
  - 25
  - 25
ratings_average:
  - 5
  - 5
  - 5
dsq_thread_id:
  - 2726264707
categories:
  - Справочник
tags:
  - STM32
  - электроника
---
Помигаем светодиодом!

Поскольку микроконтроллеры STM32 &#8212; настоящие 32-битные ARM-ядра, сделать это будет непросто. Здесь всё сильно отличается от привычных методов в PIC или AVR, где было достаточно одной строкой настроить порт на выход, а второй строкой &#8212; вывести в него значение &#8212; но тем интереснее и гибче.

<!--more-->

## Архитектура STM32

Подробно архитектура микроконтроллеров расписана в статье, однако напомню основные положения, интересные нам сейчас.

<img class="alignnone" alt="Архитектура контроллера STM32F100 в области GPIO и RCC" src="http://static.catethysis.ru/files/STM32_GPIO_architect.png" width="741" height="400" />

Ядро тактируется кварцем, обычно через ФАПЧ. Это &#8212; **тактовая частота ядра**, или **SYSCLK**. На плате STM32VLDiscovery установлен кварц на 8 МГц, а ФАПЧ в большинстве случаев настраивается как умножитель на 3 &#8212; т.е. SYSCLK на плате STM32VLDiscovery обычно равен 24 МГц.

От ядра отходит шина **AHB**, имеющая свою тактовую частоту &#8212; ей можно установить некий прескалер относительно SYSCLK, однако можно оставить его равным единице. Эта шина подобна шине между процессором и северным мостом компьютера &#8212; точно так же она служит для связи ARM ядра и процессора периферии, а также на ней висит память и конечно, контроллер DMA.

К шине AHB подключены две периферийных шины &#8212; **APB1** и **APB2**. Они равнозначны, просто обслуживают разные контроллеры интерфейсов. Частоты обоих шин APB1 и APB2 можно задавать собственными прескалерами относительно AHB, но их тоже можно оставить равными единице. По умолчанию после запуска микроконтроллера вся периферия на шинах APB1 и APB2 **отключена** в целях экономии энергии.

Интересующие нас контроллеры портов ввода-вывода висят на шине APB2.

## Модель периферии в STM32

Вся периферия микроконтроллеров STM32 настраивается по стандартной процедуре.

  1. Включение тактирования соответствующего контроллера &#8212; буквально, подача на него тактового сигнала от шины APB;
  2. Настройки, специфичные для конкретной периферии &#8212; что-то записываем в управляющие регистры;
  3. Выбор источников прерываний &#8212; каждый периферийный блок может генерировать прерывания по разным поводам. Можно выбрать конкретные &#171;поводы&#187;;
  4. Назначение обработчика прерываний;
  5. Запуск контроллера.

Если прерывания не нужны &#8212; шаги 3 и 4 можно пропустить.

Вот, к примеру, инициализация [таймера](http://catethysis.ru/stm32-%e2%86%92-%d1%82%d0%b0%d0%b9%d0%bc%d0%b5%d1%80%d1%8b-%e2%86%92-%d1%88%d0%b8%d0%bc/ "STM32 → таймеры → ШИМ") (указаны шаги из последовательности):

<pre><code class="cpp">/* 1 */ RCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN;
/* 2 */ TIM6-&gt;PSC = 24000;
        TIM6-&gt;ARR = 1000;
/* 3 */ TIM6-&gt;DIER |= TIM_DIER_UIE;
/* 4 */ NVIC_EnableIRQ(TIM6_DAC_IRQn);
/* 5 */ TIM6-&gt;CR1 |= TIM_CR1_CEN;</code></pre>

## Контроллер портов ввода-вывода

Наконец-то подобрались к основной теме статьи.

Так устроена одна нога ввода-вывода микроконтроллера STM32F100:

<img class="alignnone" alt="Структура одной ножки ввода-вывода микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_GPIO_schem.png" />

Выглядит сложнее, чем в PIC или AVR  <img src="http://catethysis.ru/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" />Но на самом деле, ничего страшного.

На входе стоят защитные диоды, не дающие опустить потенциал ножки ниже земли или поднять его выше напряжения питания. Следом установлены управляемые подтягивающие резисторы &#8212; по желанию ножку можно подтянуть к земле или к питанию. Однако нужно помнить что эти подтяжки довольно слабые.

##### Вход

Рассмотрим &#171;вход&#187;. Сигнал напрямую идёт в линию &#171;Analog&#187;, и если ножка настроена как вход АЦП или компаратора &#8212; и если эти блоки есть на этой ножке &#8212; сигнал напрямую попадает в них. Для работы с цифровыми сигналами установлен триггер Шмитта (это тот, который с гистерезисом), и его выход попадает в регистр-защёлку входных данных &#8212; вот теперь состояние ножки можно считать в программе, читая этот регистр (кстати, он называется IDR &#8212; input data register). Для обеспечения работы не-GPIO-периферии, висящей на этой ножке как на входе &#8212; сделан отвод под именем &#171;Alternate function input&#187;. В качестве этой периферии может выступать UART/USART, SPI, USB да и очень многие другие контроллеры.
  
Важно понимать, что все эти отводы одновременно включены и работают, просто к ним может быть ничего не подключено.

##### Выход

Теперь &#171;выход&#187;. Цифровые данные, записанные в порт как в выход, лежат в регистре ODR &#8212; output data register. Он доступен как на запись, так и на чтение. Читая из ODR, вы не читаете состояние ножки как входа! Вы читаете то, что сами в него записали.
  
Здесь же &#8212; выход от не-GPIO-периферии, под названием &#171;Alternate function output&#187;, и попадаем в Output driver. Режим работы выхода с точки зрения схемотехники настраивается именно здесь &#8212; можно сделать пуш-пулл выход (линия жёстко притягивается к земле или питанию), выход с открытым коллектором (притягиваем линию к питанию, а землю обеспечивает что-то внешнее, висящее на контакте) или вовсе отключить выход. После драйвера в линию входит аналоговый выход от ЦАП, компаратора или ОУ, и попадаем снова в подтягивающие резисторы и диоды.

Драйвер цифрового выхода имеет также контроль крутизны, или скорости нарастания напряжения. Можно установить максимальную крутизну, и получить возможность дёргать ногой с частотой 50 МГц &#8212; но так мы получим и сильные электромагнитные помехи из-за резких звенящих фронтов. Можно установить минимальную крутизну, с максимальной частотой &#171;всего&#187; 2 МГц &#8212; но и значительно уменьшить радиопомехи.

На картинке можно заметить ещё один регистр, &#171;Bit set/reset registers&#187;. Дело в том, что можно писать напрямую в регистр ODR, а можно использовать регистры BRR/BSRR. На самом деле, это очень крутая фича, о которой я расскажу дальше.

## Возможности

Сейчас всё стало похоже на хаос &#8212; неясно, как управлять всеми этими возможностями. Однако нет, контроллер порта отслеживает возможные режимы работы выхода, и исключает неверные комбинации &#8212; например, он не даст одновременно работать в одну выходную линию и драйверу цифрового выхода, и аналоговому выходу. Зато наличие такого количества настроек даёт обширные возможности.

Например, в более старших сериях можно настроить выход с открытым коллектором, и включить подтяжку к земле. Получается именно то, что нужно для шины 1-Wire. Правда, в серии STM32F1xx такой возможности нет, и нужно ставить внешний резистор подтяжки.

## Атомарные операции

В старых микроконтроллерах часто возникала ситуация &#8212; если мы хотим изменить какие-то биты в порту (а на самом деле просто включить или выключить ножку) &#8212; нам приходилось читать весь регистр порта, устанавливать/сбрасывать в нём нужные биты и записывать обратно. Всё было хорошо до того момента, когда эту операцию посередине не прерывало прерывание. Если обработчик этого прерывания тоже что-то делал с этим же портом &#8212; возникала крайне трудноуловимая ошибка. С этим боролись разными средствами, например глобально запрещали прерывания на время обработки порта &#8212; но согласитесь, это какой-то костыльный вариант.

В STM32 эта проблема решена аппаратным путём &#8212; у вас есть регистры установки и сброса битов (BSRR и BRR), и здесь убиты сразу три зайца:

  1. не нужно читать порт для работы с ним
  2. для воздействия на конкретные пины нужно работать с конкретными битами, а не пытаться изменять весь порт
  3. эти операции атомарны &#8212; они проходят за один цикл, и их невозможно прервать посередине.

Подробнее про &#171;конкретные биты&#187; &#8212; каждый такт APB2 читаются регистры BSRR и BRR, и сразу же их содержимое применяется на регистр ODR, а сами эти регистры очищаются.Таким образом, если нужно установить 3 и 5 биты в порте &#8212; пишем в BSRR слово 10100, и всё успешно устанавливается.

## Блокирование конфигурации

При желании, можно заблокировать конфигурацию любого пина от дальнейших изменений &#8212; любая попытка записи в регистр конфигурации окончится неуспехом. Это подойдёт для ответственных применений, где случайное переключение к примеру, выхода из режима open drain в push-pull выжжет всё подключенное к этому пину, или сам пин. Для включения блокирования предназначен регистр LCKR, только он снабжён защитой от случайной непреднамеренной записи &#8212; чтобы изменения вступили в силу, нужно подать специальную последовательность в бит LCKK.

## Управляющие регистры

Всё управление контроллером GPIO сосредоточено в 32-битных регистрах GPIOx_RRR, где x &#8212; номер порта, а RRR &#8212; название регистра.

#### Младший конфигурационный регистр GPIOx_CRL

<img class="alignnone" alt="Регистр GPIO_CRL микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_registers/GPIO_CRL.png" width="1594" height="53" />

Настраивает первые 8 ножек, с номерами 0..7. У каждой ножки два параметра, MODE и CNF.

**MODE** отвечает за режим вход/выход и скорость нарастания сигнала.
  
00 &#8212; вход (режим по умолчанию)
  
01 &#8212; выход со скоростью 10 МГц
  
10 &#8212; выход со скоростью 2 МГц
  
11 &#8212; выход со скоростью 50 МГц

**CNF** отвечает за конфигурацию пина.

  * В режиме входа (MODE=00):
  
    00 &#8212; аналоговый режим
  
    01 &#8212; плавающий вход (дефолт)
  
    10 &#8212; вход с подтяжкой к земле или питанию
  
    11 &#8212; зарезервирован
  * В режиме выхода (MODE=01, 10 или 11):
  
    00 &#8212; выход GPIO Push-pull
  
    01 &#8212; выход GPIO Open drain
  
    10 &#8212; выход альтернативной функции Push-pull
  
    11 &#8212; выход альтернативной функции Open drain

#### Старший конфигурационный регистр GPIOx_CRH

<img alt="Регистр GPIO_CRH микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_registers/GPIO_CRH.png" width="1594" height="53" />

Настраивает вторые 8 ножек, с номерами 8..15. Всё аналогично GPIOx_CRL.

#### Регистр входных данных GPIOx_IDR

<img class="alignnone" alt="Регистр GPIO_IDR микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_registers/GPIO_IDR.png" width="1573" height="195" />

Каждый бит IDRy содержит в себе состояние соответствующей ножки ввода-вывода. Доступен только для чтения.

#### Регистр входных данных GPIOx_ODR

<img class="alignnone" alt="Регистр GPIO_ODR микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_registers/GPIO_ODR.png" width="1573" height="195" />

Каждый бит ODRy содержит в себе состояние соответствующей ножки ввода-вывода. Можно записывать данные и они появятся на выходе порта, можно читать данные &#8212; читая предыдущее записанное значение.

#### Регистр атомарной установки/сброса битов выходных данных GPIOx_BSRR

<img class="alignnone" alt="Регистр GPIO_BSRR микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_registers/GPIO_BSRR.png" width="1573" height="196" />

Старшие 16 бит &#8212; для сброса соответствующих пинов в 0. 0 &#8212; ничего не делает, 1 &#8212; сбрасывает соответствующий бит. Младшие 16 бит &#8212; для установки битов в 1. Точно так же, запись &#171;0&#187; ничего не делает, запись &#171;1&#187; устанавливает соответствующий бит в 1.

Регистр только для записи &#8212; он сбрасывается в ноль на каждом такте APB2.

#### Регистр атомарного сброса битов выходных данных GPIOx_BRR

<img alt="Регистр GPIO_BRR микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_registers/GPIO_BRR.png" width="1573" height="196" />

Младшие 16 бит &#8212; для сброса соответствующих пинов. 0 &#8212; ничего не делает, 1 &#8212; сбрасывает соответствующий бит.

Регистр только для записи &#8212; он сбрасывается в ноль на каждом такте APB2.

#### Регистр блокирования конфигурации GPIOx_LCKR

<img class="alignnone" alt="Регистр GPIO_LCKR микроконтроллера STM32F100" src="http://static.catethysis.ru/files/STM32_registers/GPIO_LCKR.png" width="1573" height="196" />

Каждый бит LCKy блокирует соответствующие биты MODE/CNF регистров CRL/CRH от изменения, таким образом конфигурацию пина невозможно будет изменить вплоть до перезагрузки. Для активации блокирования необходимо записать блокирующую последовательность в бит LCKK: 1, 0, 1, читаем 0, читаем 1. Чтение бита LCKK сообщает текущий статус блокировки: 0 &#8212; блокировки нет, 1 &#8212; есть.

## Работа в разных режимах

#### Режим входа

  * Отключается драйвер выхода
  * <span style="line-height: 1.5;">Входной триггер Шмитта включен</span>
  * Резисторы подтяжек включаются по вашим настройкам, одно из трёх состояний &#8212; &#171;вход, подтянутый к земле&#187;, &#171;вход, подтянутый к питанию&#187;, или &#171;плавающий вход&#187;
  * Входной сигнал семплируется каждый такт шины APB2 и записывается в регистр IDR, и чтение этого регистра сообщает состояние ножки.

#### Режим выхода

  * Драйвер выхода включен, и действует так:
  
    В режиме &#171;Push-Pull&#187; работает как полумост, включая верхний транзистор в случае &#171;1&#187; и нижний в случае &#171;0&#187;,
  
    В режиме &#171;Open drain&#187; включает нижний транзистор в случае &#171;0&#187;, а в случае &#171;1&#187; оставляет линию неподключенной (т.е. в третьем состоянии).
  * Входной триггер Шмитта включен
  * Отключаются резисторы подтяжек
  * Выходной сигнал семплируется каждый такт шины APB2 и записывается в регистр IDR, и чтение этого регистра сообщает состояние ножки в режиме Open drain.
  * Чтение регистра ODR сообщает последнее записанное состояние в режиме Push-Pull.

#### Режим альтернативной функции (не-GPIO-периферия)

  * Выходной драйвер &#8212; в режиме Push-Pull (к примеру, так работает [ножка TX модуля USART](http://catethysis.ru/stm32-%e2%86%92-uart-usart/ "STM32 → UART / USART")) или Open drain, в зависимости от требований контроллера
  * Выходной драйвер управляется сигналами периферии, а не регистром ODR
  * Входной триггер Шмитта включен
  * Резисторы подтяжки отключены
  * Выходной сигнал семплируется каждый такт шины APB2 и записывается в регистр IDR, и чтение этого регистра сообщает состояние ножки в режиме Open drain.
  * Чтение регистра ODR сообщает последнее записанное состояние в режиме Push-Pull.

#### Аналоговый режим

  * Выходной драйвер выключен
  * Триггер Шмитта полностью отключается, чтобы не влиять на напряжение на входе
  * Резисторы подтяжки отключены
  * В регистре IDR &#8212; постоянно 0.

Вся внутренняя аналоговая периферия имеет высокий входной импеданс, поэтому и сама ножка по отношению к остальной схеме будет иметь высокий входной импеданс.

## Наконец-то включаем светодиод

Теперь мы знаем всё, чтобы включить этот светодиод! Пойдём с самого начала.

Нужно включить тактирование GPIO порта. Поскольку мы используем светодиод на плате Discovery, выберем зелёный &#8212; он подключен к порту PC9. То есть, необходимо включить тактирование GPIOC.
  
RCC->APB2ENR|= RCC\_APB2ENR\_IOPCEN;

Супер, теперь настраиваем порт на Push-pull выход со скоростью 2 МГц. Сначала выбираем режим, &#171;Output mode, max speed 2 MHz&#187; это 10 в регистре MODE. Достаточно просто установить второй бит.
  
GPIOC->CRH |= GPIO\_CRH\_MODE9_1;

Теперь говорим про Push-pull выход. Это соответствует 00 в регистре CNF.
  
GPIOC->CRH &= !(GPIO\_CRH\_CNF9\_0 | GPIO\_CRH\_CNF9\_1);

Устанавливаем долгожданный бит в регистре BSRR!
  
GPIOC->BSRR |= GPIO\_BSRR\_BS9;

Ну вот, честно говоря и всё. Напоследок &#8212; листинг мигающего светодиода <img src="http://catethysis.ru/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" />

<pre><code class="cpp">#include "stm32f10x.h"

int main(void)
{
  RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN;
  GPIOC-&gt;CRH &= !(GPIO_CRH_CNF9_0 | GPIO_CRH_CNF9_1);
  GPIOC-&gt;CRH |= GPIO_CRH_MODE9_1;
  uint32_t i, n=1000000;
  while(1) {
    GPIOC-&gt;BSRR |= GPIO_BSRR_BS9;
    i=0; while(i++&lt;n);
    GPIOC-&gt;BRR |= GPIO_BRR_BR9;
    i=0; while(i++&lt;n);
  }
}</code></pre>

## Библиотека itacone

И всё-таки ещё не всё. Ради упрощения всяческих настроек я делаю [библиотеку itacone](http://catethysis.ru/index.php/stm32-itacone-library/ "Библиотека для STM32 — itacone"). На текущий момент в ней реализована работа с GPIO-пинами и пара функций общего применения &#8212; но работа продолжается.