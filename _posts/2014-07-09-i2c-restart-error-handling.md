---
id: 1887
title: Обработка ошибок и перезапуск модуля I2C
date: 2014-07-09T00:34:19+00:00
author: Catethysis
layout: post
guid: http://catethysis.ru/?p=1887
permalink: /i2c-restart-error-handling/
ratings_users:
  - 4
ratings_score:
  - 20
ratings_average:
  - 5
wp_noextrenallinks_mask_links:
  - 0
dsq_thread_id:
  - 2828009741
categories:
  - Библиотеки
tags:
  - i2c
  - STM32
  - видео
  - глюк
  - память
  - электроника
---
Сегодня в комментариях меня попросили рассмотреть работу I2C более подробно, обратить внимание на нетривиальные случаи: например, что будет в случае возникновения ошибок на линии, как такие ошибки обрабатывать? Дело в том, что при появлении таких ошибок модуль I2C часто &#171;зависает&#187;, и не реагирует на дальнейшие обращения &#8212; нужно ловить такую ситуацию и перезапускать модуль.

Стандартная процедура общения с I2C-модулем предусматривает отправку байт и проверку флага &#8212; передано или нет. Флаг проверяется в цикле while, и именно этот цикл подвержен зависаниям &#8212; если флаг не устанавливается из-за ошибки, из этого цикла мы уже не выйдем никогда.

Я предлагаю простой способ выхода из этой ситуации &#8212; вместо простого while нужно сделать &#171;while с условием&#187;. К примеру, если цикл опроса флага безрезультатно прокрутился более 200 раз &#8212; наверное ситуация уже не изменится, т.к. возникла ошибка. Значит нужно перезагружать модуль I2C.

Сделать это просто: добавим переменную &#171;таймаут&#187; = 200, и в цикле опроса флага будем её декрементировать. Как только она дошла до нуля &#8212; сбрасываем текущую передачу и перезапускаем модуль. Очень важно именно отменить передачу, потому что иначе после перезапуска модуля она продолжится с того места, где застряла в прошлый раз &#8212; ну и ни к чему хорошему это не приведёт.

<!--more-->

Код примера, демонстрирующего эту &#171;безопасную передачу&#187;, таков:

<pre><code class="cpp">void delay()
{
	for(volatile uint32_t del = 0; del&lt;250000; del++);
}

typedef enum { EVENT, FLAG } OCCASION;

ErrorStatus wait_for(OCCASION occasion, uint32_t I2C_FLAG_OR_EVENT)
{
	uint16_t ticks = 200; // таймаут - 200 проверок события или флага. нужно подбирать это значение.
	while(	(occasion == FLAG ? I2C_GetFlagStatus(I2C1, I2C_FLAG_OR_EVENT) : !I2C_CheckEvent(I2C1, I2C_FLAG_OR_EVENT))
		  	&&
			ticks) // а не вышел ли таймаут?
		ticks--;
	
	if(ticks == 0)
	/*
	вышли из while по таймауту, это нестандартная ситуация - значит, произошла ошибка.
	честно говоря, сейчас не очень интересно что за ошибка -  просто вернём значение ERROR.
	при желании можно спросить текущий статус в регистрах статуса SR1 и SR2.
	*/
	{
		I2C_DeInit(I2C1);
			delay();
		I2C_init();
			delay();
		return ERROR; // Ошибка в модуле I2C, теперь нужно прервать текущие операции
	}
	return SUCCESS;
}

ErrorStatus I2C_single_write(uint8_t HW_address, uint8_t data)
{
	/*
	переходим к следующему действию только если предыдущее выполнено со статусом SUCCESS
	как только в любом действии получаем ERROR - сразу выходим из всей функции.
	*/
	I2C_GenerateSTART(I2C1, ENABLE);
		if(wait_for(EVENT, I2C_EVENT_MASTER_MODE_SELECT) == ERROR) return ERROR;
		// раньше было while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
	I2C_Send7bitAddress(I2C1, HW_address, I2C_Direction_Transmitter);
		if(wait_for(EVENT, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR) return ERROR;
	I2C_SendData(I2C1, data);
		if(wait_for(EVENT, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR) return ERROR;
	I2C_GenerateSTOP(I2C1, ENABLE);
		if(wait_for(FLAG, I2C_FLAG_BUSY) == ERROR) return ERROR;
	return SUCCESS;
}</code></pre>

И в заключение пару слов, почему я сделал именно так, ведь более логичным было бы добавление прерываний на ошибки и обработка этих прерываний. Я просто хотел как можно меньше менять исходный код, сделать это проще всего оказалось именно расширив стандартный while до такого &#171;while с таймаутом&#187;. Более того, так можно обойтись без глобальных переменных, а это всегда очень хорошо.

Введение обработчиков прерываний ошибок раздуло бы код и спрятало бы основную логику. Мне это неудобно. Кстати, подобная проблема встречалась у меня при работе микроконтроллера LM3S с RFID-ридером, я думаю такой подход решил бы её.

Этот код проверен в течение нескольких десятков замыканий SDA и SCL друг на друга и на землю: возникает ошибка, попадаем в обработчик ошибки, перезапускаем I2C и обмен продолжается. Таймаут и длительность пауз при перезапуске модуля нужно подгонять под свою скорость MK, мой код отлажен под 72 МГц, использован МК STM32F107. Тип ErrorStatus описан в заголовочном файле stm32f10x.h, можно было и без него &#8212; но с enum удобнее работать, чем с 0 и 1.